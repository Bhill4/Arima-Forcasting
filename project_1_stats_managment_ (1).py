# -*- coding: utf-8 -*-
"""project 1 stats managment .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/144Br_PxSPgd1rBRT9HYB0y85atwavoBt
"""

pip install pandas matplotlib seaborn statsmodels yfinance

import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.arima.model import ARIMA

#visualization style
sns.set(style="whitegrid")
plt.rcParams["figure.figsize"] = (10, 6)

#  historical stock data ( Apple)
ticker = 'AAPL'
data = yf.download(ticker, start="2018-01-01", end="2023-01-01")
data = data[['Close']]
data.rename(columns={'Close': 'Price'}, inplace=True)
print(data.head())

plt.plot(data['Price'])
plt.title(f'{ticker} Stock Price (2018 - 2023)')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.show()

import numpy as np

data['Log_Price'] = np.log(data['Price'])
plt.plot(data['Log_Price'])
plt.title(f'Log-Transformed {ticker} Stock Price')
plt.xlabel('Date')
plt.ylabel('Log Price')
plt.show()

from statsmodels.tsa.stattools import adfuller

result = adfuller(data['Log_Price'])
print(f'ADF Statistic: {result[0]}')
print(f'p-value: {result[1]}')

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

plot_acf(data['Log_Price'].diff().dropna(), lags=30)
plt.show()

plot_pacf(data['Log_Price'].diff().dropna(), lags=30)
plt.show()

#  training and testing sets (80% train, 20% test)
train_size = int(len(data) * 0.8)
train, test = data['Log_Price'][:train_size], data['Log_Price'][train_size:]

#  ARIMA model
model = ARIMA(train, order=(1, 1, 1))
model_fit = model.fit()

#  model summary
print(model_fit.summary())





data = data.asfreq('ME')  # 'M' stands for monthly frequency

# Forecasting
forecast_mean_interpolated = forecast_mean.interpolate(method='linear')

# Plot the interpolated forecast
plt.plot(train.index, train, label='Training Data')
plt.plot(test.index, test, label='Test Data', color='orange')
plt.plot(forecast_index, forecast_mean_interpolated, label='Interpolated Forecast', color='green')
plt.fill_between(forecast_index, forecast_ci.iloc[:, 0], forecast_ci.iloc[:, 1], color='green', alpha=0.2)
plt.title(f'{ticker} ARIMA Forecast (Interpolated)')
plt.xlabel('Date')
plt.ylabel('Log Price')
plt.legend()
plt.show()

import numpy as np
from sklearn.metrics import mean_absolute_error, mean_squared_error

#  metrics
test_values = test.values

#  forecast values  same length as the test set
forecast = model_fit.get_forecast(steps=len(test))  # Adjust forecast steps
forecast_values = forecast.predicted_mean.values

# Check for NaNs and replace with mean)
test_values = np.nan_to_num(test_values)  #replacinging with 0
forecast_values = np.nan_to_num(forecast_values) # replacing with 0

mae = mean_absolute_error(test_values, forecast_values)
rmse = mean_squared_error(test_values, forecast_values, squared=False)

print(f'Mean Absolute Error (MAE): {mae:.4f}')
print(f'Root Mean Squared Error (RMSE): {rmse:.4f}')

# 30 more days into the future
future_forecast = model_fit.get_forecast(steps=30)
future_forecast_mean = future_forecast.predicted_mean
future_forecast_ci = future_forecast.conf_int()

 # future forecast
plt.plot(data.index, data['Log_Price'], label='Historical Data')
plt.plot(future_forecast_mean.index, future_forecast_mean, label='Future Forecast', color='red')
plt.fill_between(future_forecast_ci.index, future_forecast_ci.iloc[:, 0], future_forecast_ci.iloc[:, 1], color='red', alpha=0.2)
plt.title(f'{ticker} Future Price Forecast')
plt.xlabel('Date')
plt.ylabel('Log Price')
plt.legend()
plt.show()